You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI and Tailwind.

Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.

Performance Optimization

- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC).
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazy loading.

Key Conventions

- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).
- Limit 'use client':
    - Favor server components and Next.js SSR.
    - Use only for Web API access in small components.
    - Avoid for data fetching or state management.

Follow Next.js docs for Data Fetching, Rendering, and Routing.

# Iconos Font Awesome

- Los iconos que se usan en todo el proyecto son de font-awesome
- Utiliza siempre el componente IconFA para crear iconos:
    - Importa el componente: import IconFA from '@/components/ui/IconFA';
    - Uso básico: <IconFA icon="nombre-del-icono" />
    - Con estilo: <IconFA icon="nombre-del-icono" style="duotone|solid|regular|light|brands" />
    - Con tamaño: <IconFA icon="nombre-del-icono" size="xs|sm|lg|xl|2xl" />
    - Con clase personalizada: <IconFA icon="nombre-del-icono" className="text-green-500" />
    - No uses el prefijo "fa-" al especificar el nombre del icono
- Evita usar elementos <i> directamente con clases de Font Awesome
- Los nombres de iconos están en kebab-case (usando guiones): "user-graduate", "chart-line", "people-group"

# Componentes Core

- Utiliza componentes core para mantener la consistencia visual y funcional:

    - Importa los componentes desde sus respectivas rutas:
        ```typescript
        import Input from '@/components/form/input/InputField';
        import Label from '@/components/form/Label';
        import Select from '@/components/form/Select';
        import Button from '@/components/core/button/Button';
        import Badge from '@/components/core/badge/Badge';
        import {Table, TableHeader, TableBody, TableRow, TableCell} from '@/components/core/table';
        import {Modal} from '@/components/ui/modal';
        ```
    - Para cada componente form:

        - Usa `Label` siempre con atributo htmlFor para accesibilidad
        - Usa `Input` con startIcon cuando necesites iconos prepend
        - Para `Select` usa opciones con estructura `{value: string, label: string}`
        - Siempre maneja onChange en componentes controlados

    - Para tablas:

        - Usa estructura completa (Table, TableHeader, TableRow, TableCell)
        - Marca celdas de header con la prop `isHeader={true}`
        - Usa className para personalizar el estilo de las celdas

    - Para botones:
        - Especifica siempre la variante: `variant="primary|outline|danger"`
        - Usa `startIcon` para añadir iconos al botón
        - Desactiva botones durante operaciones asíncronas con `disabled={isLoading}`

# Loading States

- Implementa estados de carga para todas las operaciones asíncronas:

    - Define variables de estado para cada sección que requiera carga:

        ```typescript
        const [isLoadingData, setIsLoadingData] = useState(true);
        const [isLoadingMetrics, setIsLoadingMetrics] = useState(true);
        const [isSaving, setIsSaving] = useState(false);
        ```

    - Muestra indicadores de carga en cada sección cuando corresponda:

        ```typescript
        {isLoadingData ? (
            <div className="flex items-center justify-center h-[200px]">
                <IconFA icon="spinner" spin className="text-gray-400" />
            </div>
        ) : (
            // Contenido real
        )}
        ```

    - Para componentes de métricas:
        - Siempre muestra un mensaje "Sin datos" cuando el array de datos esté vacío
        - Usa consistentemente los mismos patrones de altura (h-[200px]) para contenedores de carga
    - Para gráficos:
        - Muestra skeletons o spinners mientras cargan los datos
        - Define opciones base para ApexCharts y personaliza solo lo necesario
        - Verifica siempre que haya datos antes de renderizar gráficos

# Gestión de Datos

- Usa funciones asíncronas claramente nombradas para cargar datos:

    ```typescript
    async function loadData() {
        setIsLoading(true);
        try {
            // Lógica de carga de datos
        } catch (error) {
            console.error('Error específico:', error);
            // Manejo de errores
        } finally {
            setIsLoading(false);
        }
    }
    ```

- Para ordenamiento y filtrado:

    - Define funciones reutilizables (sortData, filterData)
    - Separa la lógica de ordenamiento de la presentación
    - Usa useEffect para actualizar datos filtrados cuando cambien dependencias

- Para paginación:
    - Usa funciones helpers como `paginateItems` que reciban array y devuelvan porción
    - Implementa controles de paginación estandarizados
    - Muestra contador de registros visibles vs totales
